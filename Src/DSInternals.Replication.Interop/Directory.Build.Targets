<Project>
  <Target Name="CopyDllsToPowerShell" AfterTargets="Build">
    <PropertyGroup>
      <!-- Custom properties referenced by the Copy tasks below -->
      <!-- We need to rename the platform to match the values that are used in the PROCESSOR_ARCHITECTURE environment variable. -->
      <TargetProcessorArchitecture Condition="'$(Platform)'=='x64'">amd64</TargetProcessorArchitecture>
      <TargetProcessorArchitecture Condition="'$(Platform)'=='Win32'">x86</TargetProcessorArchitecture>
      <TargetProcessorArchitecture Condition="'$(Platform)'=='ARM64'">arm64</TargetProcessorArchitecture>
      <!-- DotNet Framework variable -->
      <PowerShellModulePath Condition="'$(CLRSupport)' == 'true'">$(MSBuildThisFileDirectory)..\..\Build\bin\DSInternals.PowerShell\$(Configuration)\DSInternals\net48\$(TargetProcessorArchitecture)\</PowerShellModulePath>
      <!-- DotNet Core variable -->
      <PowerShellModulePath Condition="'$(CLRSupport)' == 'NetCore'">$(MSBuildThisFileDirectory)..\..\Build\bin\DSInternals.PowerShell\$(Configuration)\DSInternals\$(TargetFramework)-$(TargetPlatformIdentifier)\$(TargetProcessorArchitecture)\</PowerShellModulePath>
    </PropertyGroup>
    <ItemGroup>
       <!-- 
       The C runtime library (vcruntime<version>.dll or legacy msvcr<version>.dll) and the C++ standard library (msvcp<version>.dll) cannot be statically linked to mixed native and managed DLLs.
       Thanks to the CopyCppRuntimeToOutputDir setting, we can copy the correct runtime libraries from the output directory, instead of looking for them in "C:\Program Files\...".
       The msvcr140.dll / msvcr140d.dll files have been replaced by vcruntime140.dll / vcruntime140d.dll since Visual Studio 2017.
       The vcruntime140_1.dll / vcruntime140_1d.dll file is also required when not statically linked.
       Moreover, $(PlatformToolsetVersion) equals to 150 instead of 140 and thus does not match the names of the runtime files.
       For Debug builds, the ucrtbased.dll file is also required.
       -->
      <CppRuntimeBinaries Include="$(OutDir)msvc????.dll;$(OutDir)vcruntime???.dll;$(OutDir)vcruntime???_?.dll" Condition="'$(Configuration)' == 'Release'" />
      <CppRuntimeBinaries Include="$(OutDir)msvc????d.dll;$(OutDir)vcruntime???d.dll;$(OutDir)vcruntime???_?d.dll;$(OutDir)ucrtbased.dll" Condition="'$(Configuration)' == 'Debug'" />
    </ItemGroup>
    <!-- Copy the C and C++ runtime files to the PowerShell module. -->
    <Copy SourceFiles="@(CppRuntimeBinaries)" DestinationFolder="$(PowerShellModulePath)" />
    <!-- Copy the .NET IJW host to the PowerShell module. -->
    <Copy SourceFiles="$(OutDir)Ijwhost.dll" DestinationFolder="$(PowerShellModulePath)" Condition="'$(CLRSupport)' == 'NetCore'" />
    <!-- Copy the compiled DLLs to the PowerShell module. -->
    <Copy SourceFiles="$(OutDir)$(TargetName).dll" DestinationFolder="$(PowerShellModulePath)" />
    <!-- Include the debug symbols as well. -->
    <Copy SourceFiles="$(OutDir)$(TargetName).pdb" DestinationFolder="$(PowerShellModulePath)" />
  </Target>
  <!-- This is a dummy NuGet pack target to avoid error MSB4057: The target "Pack" does not exist in the project. -->
  <Target Name="Pack" />
</Project>
